function simvar = starter_script(varargin)
%%%% STARTING MESSAGES PART FOR THIS RUN
dbgmsg('=======================================================================================================================================================================================================================================')
dbgmsg('Running starter script')
dbgmsg('=======================================================================================================================================================================================================================================')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
global VERBOSE LOGIT TEST
VERBOSE = true;
LOGIT = true;
TEST = false; % set to false to actually run it

% Each trial is trained on freshly partitioned/ generated data, so that we
% have an unbiased understanding of how the chained-gas is classifying.
%
% They are generated in a way that you can use nnstart to classify them and
% evaluated how much better (or worse) a neural network or some other
% algorithm can separate these datasets. Also, the data for each action
% example has different length, so the partition of datapoints is not
% equitative (there will be some fluctuation in the performance of putting
% every case in one single bin) and it will not be the same in validation
% and training sets. So in case this is annoying to you and you want to run
% always with a similar dataset, set
% simvar.generatenewdataset = false


env = aa_environment; % load environment variables

%creates a structure with the results of different trials
env.cstfilename=strcat(env.wheretosavestuff,env.SLASH,'cst.mat');
if exist(env.cstfilename,'file')
    loadst = load(env.cstfilename,'simvar');
    simvar = loadst.simvar;
end
if ~exist('simvar','var')
    simvar = struct();
else
    simvar(end+1).nodes = [];%cst(1);
end

%% Choose dataset
if isempty(varargin)
    simvar(end).featuresall = 1;
    simvar(end).realtimeclassifier = false;
    simvar(end).generatenewdataset = true;
    simvar(end).datasettype = 'CAD60'; % datasettypes are 'CAD60', 'tstv2' and 'stickman'
    simvar(end).sampling_type = 'type2';
    simvar(end).activity_type = 'act_type'; %'act_type' or 'act'
    simvar(end).prefilter = 'none'; % 'filter', 'none', 'median?'
    simvar(end).labels_names = []; % necessary so that same actions keep their order number
    simvar(end).TrainSubjectIndexes = 'all';%[9,10,11,4,8,5,3,6]; %% comment these out to have random new samples
    simvar(end).ValSubjectIndexes = 1;%[];%[1,2,7];%% comment these out to have random new samples
    simvar(end).randSubjEachIteration = true;
    simvar(end).extract = {'rand', 'wantvelocity'};
    simvar(end).preconditions = {'nohips', 'normal', 'norotatehips','mirrorx'};
    simvar(end).trialdataname = strcat('skel',simvar(end).datasettype,'_',simvar(end).sampling_type,simvar(end).activity_type,'_',simvar(end).prefilter, [simvar(end).extract{:}],[simvar(end).preconditions{:}]);
    simvar(end).trialdatafile = strcat(env.wheretosavestuff,env.SLASH,simvar(end).trialdataname,'.mat');
else
    simvar(end).featuresall = 3;%size(varargin{1},2);
    simvar(end).generatenewdataset = false;
    simvar(end).datasettype = 'Ext!';
    simvar(end).sampling_type = '';
    simvar(end).activity_type = ''; %'act_type' or 'act'
    simvar(end).prefilter = 'none'; % 'filter', 'none', 'median?'
    simvar(end).labels_names = []; % necessary so that same actions keep their order number
    simvar(end).TrainSubjectIndexes = [];%[9,10,11,4,8,5,3,6]; %% comment these out to have random new samples
    simvar(end).ValSubjectIndexes = [];%[1,2,7];%% comment these out to have random new samples
    simvar(end).randSubjEachIteration = true;
    simvar(end).extract = {''};
    simvar(end).preconditions = {''};
    simvar(end).trialdataname = strcat('other',simvar(end).datasettype,'_',simvar(end).sampling_type,simvar(end).activity_type,'_',simvar(end).prefilter, [simvar(end).extract{:}],[simvar(end).preconditions{:}]);
    simvar(end).trialdatafile = strcat(env.wheretosavestuff,env.SLASH,simvar(end).trialdataname,'.mat');
end

%% Setting up runtime variables

% set other additional simulation variables
simvar(end).TEST = TEST; %change this in the beginning of the program
simvar(end).PARA = 0;
simvar(end).P = 1;
simvar(end).NODES_VECT = 1000;
simvar(end).MAX_EPOCHS_VECT = [1];
simvar(end).ARCH_VECT = [8];
simvar(end).MAX_NUM_TRIALS = 1;
simvar(end).MAX_RUNNING_TIME = 1;%3600*10; %%% in seconds, will stop after this

% set parameters for gas:

params.MAX_EPOCHS = [];
params.removepoints = true;
params.PLOTIT = false;
params.RANDOMSTART = true; % if true it overrides the .startingpoint variable
params.RANDOMSET = true; % if true, each sample (either alone or sliding window concatenated sample) will be presented to the gas at random
params.savegas.resume = false; % do not set to true. not working
params.savegas.save = false;
params.savegas.path = env.wheretosavestuff;
params.savegas.parallelgases = true;
params.savegas.parallelgasescount = 0;
params.savegas.accurate_track_epochs = true;
params.savegas.P = simvar(end).P;
params.startingpoint = [1 2];
params.amax = 50; %greatest allowed age
params.nodes = []; %maximum number of nodes/neurons in the gas
params.en = 0.006; %epsilon subscript n
params.eb = 0.2; %epsilon subscript b
params.gamma = 1; % for the denoising function
params.plottingstep = 0; % zero will make it plot only the end-gas

%Exclusive for gwr
params.STATIC = true;
params.at = 0.95; %activity threshold
params.h0 = 1;
params.ab = 0.95;
params.an = 0.95;
params.tb = 3.33;
params.tn = 3.33;

%Exclusive for gng
params.age_inc                  = 1;
params.lambda                   = 3;
params.alpha                    = .5;     % q and f units error reduction constant.
params.d                           = .99;   % Error reduction factor.


%% Begin loop
for architectures = simvar(end).ARCH_VECT
    for NODES = simvar(end).NODES_VECT
        for MAX_EPOCHS = simvar(end).MAX_EPOCHS_VECT
            for featuress = 1:simvar(end).featuresall
                if NODES ==100000 && (simvar(end).MAX_EPOCHS==1||simvar(end).MAX_EPOCHS==1)
                    dbgmsg('Did this already',1)
                    break
                end
                simvar(end).arch = architectures;
                simvar(end).NODES =  NODES;
                simvar(end).MAX_EPOCHS = MAX_EPOCHS;
                
                params.MAX_EPOCHS = simvar(end).MAX_EPOCHS;
                params.nodes = simvar(end).NODES; %maximum number of nodes/neurons in the gas
                
                %% Loading data
                if isempty(varargin)
                    datasetmissing = false;
                    if ~exist(simvar(end).trialdatafile, 'file')&&~simvar(end).generatenewdataset
                        dbgmsg('There is no data on the specified location. Will generate new dataset.',1)
                        datasetmissing = true;
                    end
                    if simvar(end).generatenewdataset||datasetmissing
                        [allskel1, allskel2, simvar(end).TrainSubjectIndexes, simvar(end).ValSubjectIndexes] = generate_skel_data(simvar(end).datasettype, simvar(end).sampling_type, simvar(end).TrainSubjectIndexes, simvar(end).ValSubjectIndexes, simvar(end).randSubjEachIteration);
                        [allskel1, allskel2] = conformactions(allskel1,allskel2, simvar(end).prefilter); %%% should be split in 2
                        [data.train, simvar(end).labels_names] = extractdata(allskel1, simvar(end).activity_type, simvar(end).labels_names,simvar(end).extract{:});
                        [data.train, params.skelldef] = conformskel(data.train, simvar(end).preconditions{:});
                        %does same for validation data
                        [data.val, simvar(end).labels_names] = extractdata(allskel2, simvar(end).activity_type, simvar(end).labels_names,simvar(end).extract{:});
                        [data.val, ~                ] = conformskel(data.val,   simvar(end).preconditions{:}); 

                        simvar(end).trialdatafile = savefilesave(simvar(end).trialdataname, {data, simvar,params},env);
                        %save(simvar(end).trialdataname,'data', 'simvar','params');
                        dbgmsg('Training and Validation data saved.')
                        clear datasetmissing
                    else
                        loadedtrial = loadfileload(simvar(end).trialdataname,env);
                        data = loadedtrial.data;
                        params.skelldef = loadedtrial.params.skelldef;
                        simvar(end).generatenewdataset = false;
                    end
                    simvar(end).datainputvectorsize = size(data.train.data,1);
                else
                    data = varargin{1};
                    data = data(featuress);                    
                    simvar(end).datainputvectorsize = size(data.inputs,2);
                    params.skelldef = struct('length', simvar(end).datainputvectorsize, 'notskeleton', true, 'awk', struct('pos', [],'vel',[]), 'pos', simvar(end).datainputvectorsize, 'vel', []);
                    data.train.data = data.inputs'; % not empty so that the algorithm doesnt complain
                    data.train.y = data.labelsM;
                    data.train.ends = ones(1,size(data.inputs,1));
                    data.val.data = data.inputs';
                    data.val.y = data.labelsM;
                    data.val.ends = ones(1,size(data.inputs,1));                    
                end
                
                %% Classifier structure definitions
                
                simvar(end).allconn = allconnset(simvar(end).arch, params);
                
                
                %% Setting up different parameters for each of parallel tria
                % Maybe you want to do that; in case you don't, then we just
                % use a for to put the same parameters for each.
                a = struct([]);
                for i = 1:simvar(end).P
                    simvar(end).paramsZ(i) = params;
                    a(i).a = struct([]);
                end
                
                clear a
                b = [];
                
                if ~TEST % there are so many different ways I want to test it, that this definition is pretty much pointless.
                    starttime = tic;
                    while toc(starttime)< simvar(end).MAX_RUNNING_TIME
                        if length(b)> simvar(end).MAX_NUM_TRIALS
                            break
                        end
                        if simvar(end).PARA
                            spmd(simvar(end).P)
                                a(labindex).a = executioncore_in_starterscript(simvar(end).paramsZ(labindex),simvar(end).allconn, data);
                            end
                            %b = cat(2,b,a.a);
                            for i=1:length(a)
                                c = a{i};
                                a{i} = [];
                                b = [c.a b];
                            end
                            clear a c
                            a(1:simvar(end).P) = struct();
                        else
                            for i = 1:simvar(end).P
                                a(i).a = executioncore_in_starterscript(simvar(end).paramsZ(i),simvar(end).allconn, data);
                            end
                            b = cat(2,b,a.a);
                            clear a
                            a(1:simvar(end).P) = struct();
                        end
                    end
                else
                    b = executioncore_in_starterscript(simvar(end).paramsZ(1),simvar(end).allconn, data);
                end
                
                simvar(end).metrics = gen_cst(b); %%% it takes the important stuff from b;;; hopefully
                if isempty(varargin)
                    save(strcat(env.wheretosavestuff,env.SLASH,'cst.mat'),'simvar')
                    
                    savevar = strcat('b',num2str(simvar(end).NODES),'_', num2str(params.MAX_EPOCHS),'epochs',num2str(size(b,2)), simvar(end).sampling_type, simvar(end).datasettype, simvar(end).activity_type);
                    eval(strcat(savevar,'=simvar(end);'))
                    simvar(end).savesave = savefilesave(savevar, simvar(end),env);
                    %             simvar(end).savesave = strcat(env.wheretosavestuff,env.SLASH,savevar,'.mat');
                    %             ver = 1;
                    %
                    %             while exist(simvar(end).savesave,'file')
                    %                 simvar(end).savesave = strcat(env.wheretosavestuff,env.SLASH,savevar,'[ver(',num2str(ver),')].mat');
                    %                 ver = ver+1;
                    %             end
                    %             save(simvar(end).savesave,savevar)
                    dbgmsg('Trial saved in: ',simvar(end).savesave,1)
                end
                simvar(end+1) = simvar(end);
            end
            clear b
            clock
        end
    end
end
simvar(end) = [];
end
function allconn = allconnset(n, params)
allconn_set = {...
    {... %%%% ARCHITECTURE 1
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[1 0],params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',[1 0],params}...
    {'gwr3layer',   'gwr',{'gwr1layer'},              'pos',[3 2],params}...
    {'gwr4layer',   'gwr',{'gwr2layer'},              'vel',[3 2],params}...
    {'gwrSTSlayer', 'gwr',{'gwr3layer','gwr4layer'},  'all',[3 2],params}...
    }...
    {...%%%% ARCHITECTURE 2
    {'gng1layer',   'gng',{'pos'},                    'pos',[1 0],params}...
    {'gng2layer',   'gng',{'vel'},                    'vel',[1 0],params}...
    {'gng3layer',   'gng',{'gng1layer'},              'pos',[3 2],params}...
    {'gng4layer',   'gng',{'gng2layer'},              'vel',[3 2],params}...
    {'gngSTSlayer', 'gng',{'gng4layer','gng3layer'},  'all',[3 2],params}...
    }...
    {...%%%% ARCHITECTURE 3
    {'gng1layer',   'gng',{'pos'},                    'pos',[1 0],params}...
    {'gng2layer',   'gng',{'vel'},                    'vel',[1 0],params}...
    {'gng3layer',   'gng',{'gng1layer'},              'pos',[3 0],params}...
    {'gng4layer',   'gng',{'gng2layer'},              'vel',[3 0],params}...
    {'gngSTSlayer', 'gng',{'gng4layer','gng3layer'},  'all',[3 0],params}...
    }...
    {...%%%% ARCHITECTURE 4
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[1 0],params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',[1 0],params}...
    {'gwr3layer',   'gwr',{'gwr1layer'},              'pos',[3 0],params}...
    {'gwr4layer',   'gwr',{'gwr2layer'},              'vel',[3 0],params}...
    {'gwrSTSlayer', 'gwr',{'gwr3layer','gwr4layer'},  'all',[3 0],params}...
    }...
    {...%%%% ARCHITECTURE 5
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[1 2 3],params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',[1 2 3],params}...
    {'gwr3layer',   'gwr',{'gwr1layer'},              'pos',[3 2],params}...
    {'gwr4layer',   'gwr',{'gwr2layer'},              'vel',[3 2],params}...
    {'gwrSTSlayer', 'gwr',{'gwr3layer','gwr4layer'},  'all',[3 2],params}...
    }...
    {...%%%% ARCHITECTURE 6
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[3 4 2],params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',[3 4 2],params}...
    {'gwrSTSlayer', 'gwr',{'gwr1layer','gwr2layer'},  'all',[3 2],params}...
    }...
    {...%%%% ARCHITECTURE 7
    {'gwr1layer',   'gwr',{'all'},                    'all',[3 2], params}...
    {'gwr2layer',   'gwr',{'gwr1layer'},              'all',[3 2], params}...
    }...
    {...%%%% ARCHITECTURE 8
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[1 0], params}... %% now there is a vector where q used to be, because we have the p overlap variable...
    }...
    {...%%%% ARCHITECTURE 9
    {'gwr1layer',   'gwr',{'pos'},                    'pos',3,params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',3,params}...
    {'gwr3layer',   'gwr',{'gwr1layer'},              'pos',3,params}...
    {'gwr4layer',   'gwr',{'gwr2layer'},              'vel',3,params}...
    {'gwr5layer',   'gwr',{'gwr3layer'},              'pos',3,params}...
    {'gwr6layer',   'gwr',{'gwr4layer'},              'vel',3,params}...
    {'gwrSTSlayer', 'gwr',{'gwr6layer','gwr5layer'},  'all',3,params}
    }...
    {... %%%% ARCHITECTURE 10
    {'gwr1layer',   'gwr',{'pos'},                    'pos',[1 0],params}...
    {'gwr2layer',   'gwr',{'vel'},                    'vel',[1 0],params}...
    {'gwrSTSlayer', 'gwr',{'gwr1layer','gwr2layer'},  'all',[3 2],params}...
    }...
    };
allconn = allconn_set{n};
end
function a = executioncore_in_starterscript(paramsZ,allconn, data)
global TEST
n = randperm(size(data.train.data,2)-3,2); % -(q-1) necessary because concatenation reduces the data size!
paramsZ.startingpoint = [n(1) n(2)];
pallconn = allconn;
pallconn{1,1}{1,6} = paramsZ; % I only change the initial points of the position gas
%pallconn{1,3}{1,6} = paramsZ; %but I want the concatenation to reflect the same position that I randomized. actually this is not going to happen because of the sliding window scheme
%pallconn{1,4}{1,6} = pallconn{1,2}{1,6};

%[a.sv, a.mt] = starter_sc(data, pallconn, 1);
if TEST
    dbgmsg('TEST RUN. Generating sham output data. Data will not be saved.',1)
    confconf = struct('val','val', 'train', '');
    ouout = struct('accumulatedepochs',0);
    for i =1:4
        for j =1:5
            a.mt(i,j) = struct('conffig', 'hello','confusions', confconf,'conffvig', 'hello','outparams',ouout);
        end
    end
    
else
    [~, a.mt, ~] = starter_sc(data, pallconn);
end
end




function allskel = generate_falling_stick(numsticks)

% if length(numsticks)>1
%     allskel = [];
%     for i = subject
%         allskel = [allskel generate_falling_stick(i)];
%     end
%     return
% end
stickmodel = 'skel25'; % 'rod', 'skel25', 'skel15'
thetanoisepower = 0.01;
translationnoisepower = 1;
floorsize = 1500;

for kk = 1:numsticks
    num_of_points_in_stick = 25;
    
    %%% random size
    %%% random start location
    %%% random initial velocity for falling stick
    
    l = (1.6+rand()*.3)*1000;
    
    for akk = [0,1]
        
        startlocation = floorsize*[rand(), 0.01*rand(), rand()];
        phi = 2*pi*rand();
        phinoisepower = 0.1*rand;
        initial_velocity = -1*rand();
        
        if akk
            act = 'Fall';
            % from http://www.chem.mtu.edu/~tbco/cm416/MatlabTutorialPart2.pdf and
            % from http://ocw.mit.edu/courses/mechanical-engineering/2-003j-dynamics-and-control-i-spring-2007/lecture-notes/lec10.pdf
            % the equation from the falling stick is
            %
            % -m*g*l/2*cos(t) = (Ic+m*l^2/4*cos(t)^2)*tdd - m*l^2/4*cos(t)*sin(t*td^2)
            %
            % tdd = diff(td)
            % td = diff(t)
            
            testOptions = odeset('RelTol',1e-3,'AbsTol', [1e-4; 1e-2]);
            notsatisfiedwithmodel = true;
            while(notsatisfiedwithmodel)
                [t,x] =     ode45(@stickfall, [0 2+1.5*rand()], [pi/2;initial_velocity], testOptions);
                
                
                
                %%% resample to kinect average sample rate, i.e. 15 or 30 hz
                x = resample(x(:,1),t,30);
                
                %%% upon visual inpection we see that the beginnings and ends
                %%% of the results from ode45 sequence are very noisy, possibly
                %%% due to the unnatural constraints on the differential
                %%% equation mode. Some doctoring is required:
                
                x(1,:) = x(2,:)+0.01*rand(); %%% fixing initial point
                %             %now to fix the ends it is even dirtier:
                %             plot(x(:,1))
                %             hold on
                diffx = abs(diff(x));
                for i = length(diffx):-1:3
                    if all([diffx(i-2), diffx(i-1), diffx(i)]<0.07) %this was done on trial and error basis
                        x = x(1:i);
                        if abs(x(end))<0.1||abs(x(end)-pi)<0.1 %%it has to end in a natural resting angle
                            notsatisfiedwithmodel = false;
                        end
                        break
                    end
                end
            end
            padding = x(end).*ones(round(130*rand()),1);
            padding = padding+thetanoisepower*rand(size(padding));
            x = [x;padding];
            %             plot(x(:,1))
            %             hold off
            phinoise = zeros(size(x)); %%% a freefalling stick would never change angle, ok maybe if it were spinning, or hit by something...
            translationnoise = translationnoisepower*zeros(size(x,1),3);
            [skel, vel] = construct_skel(x,l,num_of_points_in_stick ,startlocation, translationnoise, phi, phinoise, stickmodel);
            
        else
            act = 'Walk';
            %%% non falling activity
            x = pi/2*ones(90+round(25*rand()),1)+0*thetanoisepower; % does it even make sense if the velocity changes and the position does not?
            phinoise = 0*phinoisepower*rand(size(x));
            %%% the walk now
            t = linspace(0,1,length(x));
            realtransx = 2*sin(phi)*t*floorsize;
            realtransy = 0*t*floorsize;
            realtransz = 2*cos(phi)*t*floorsize;
            translationnoise = 0*translationnoisepower*rand(size(x,1),3)+[realtransx; realtransy; realtransz]';
            [skel, vel] = construct_skel(x, l, num_of_points_in_stick, startlocation, translationnoise , phi, phinoise, stickmodel);
            
        end
        %for i = 1:s
        construct_sk_struct = struct('x',x,'l',l,'num_points', num_of_points_in_stick,'startlocation',startlocation,'phi',phi);
        jskelstruc = struct('skel',skel,'act_type', act, 'index', kk, 'subject', kk,'time',[],'vel', vel, 'construct_sk_struct', construct_sk_struct);
        
        %plot(stickstick(:,1), stickstick(:,2), '*')
        if exist('allskel','var') % initialize my big matrix of skeletons
            allskel = cat(2,allskel,jskelstruc);
        else
            allskel = jskelstruc;
        end
    end
end
end
function dx = stickfall(t,x)

m = 1;
g = 9.8;
l = 1.6;
t = 0;

Ic = 1/3*m*l^2;%% for a slender rod rotating on one end

x1 = x(1);
x2 = x(2);

% state equations
% I can put any nonlinearilty I want, so I will make so that when  x1 == 0
% or x1 = pi, then the velocity changes sign, i.e. it bounces

if ((x1 < 0)&&x2<0)||((x1> pi)&&x2>0)
    dx1 = -0.5*x2; %so that it dampens as well
else
    dx1 = x2;
end

dx2 = (m*l^2/4*cos(x1*x2^2) -m*g*l/2*cos(x1))/(Ic+m*l^2/4*cos(x1)^2);

dx = [dx1;dx2];

end
function [stickstick,stickvel] = construct_skel(thetha, l, num_of_points_in_stick, displacement, tn, phi, phinoise, stickmodel)

bn = [rand(), rand(), rand()]/10; %% I need a bit of noise or the classifier gets insane

simdim = size(thetha,1); % 4;%

stickstick = zeros(num_of_points_in_stick,3,simdim);
stickvel = stickstick; %%%
switch stickmodel
    case 'rod'
        for i=1:simdim
            dpdp =  displacement+tn(i,:);
            tt=thetha(i);
            PHI = phi+phinoise(i);
            
            stickstick(1,:,i) = dpdp-l/2*cos(tt)*[cos(PHI) 0 sin(PHI)];
            for j = 2:num_of_points_in_stick
                stickstick(j,:,i) = ([cos(tt)*cos(PHI), sin(tt), cos(tt)*sin(PHI)]+bn)*l*j/num_of_points_in_stick+dpdp-l/2*cos(tt)*[cos(PHI) 0 sin(PHI)];
            end
        end
    case 'skel25'
        num_of_points_in_stick = 25;
        %%%% skeleton model was obtained after using generate_skel_data
        %protoskel = allskel1(3).skel(:,:,1) -repmat(mean(allskel1(3).skel(:,:,1)),25,1);
        prot = load('protoskel.mat');
        height = 1552;
        if ~isfield(prot,'protoskel')
            error('Problems to load protoskel.mat: skeleton model not found.')
        end
        for i=1:simdim
            dpdp =  displacement+tn(i,:);
            tt=thetha(i);
            PHI = phi+phinoise(i);
            %%% will need to make 2 rotation matrices
            % PHI is first, it is a rotation around the y axis
            %             PHIMAT = [[cos(PHI) 0 sin(PHI)];[0 1 0];[-sin(PHI) 0 cos(PHI)]];
            %             % now, is a fall a rotation on x or z axis?
            %             % I will do both and comment out the one I dislike; or maybe I
            %             % can make it a different kind of fall.
            %             %around x
            %             if 1
            %                 ttmatx = [[1 0 0 ];[0 cos(tt) -sin(tt)];[0 sin(tt) cos(tt)]];
            %                 ttmatz = eye(3);
            %             else
            %                 %around z
            %                 ttmatx = eye(3);
            %                 ttmatz = [[cos(tt) -sin(tt) 0];[sin(tt) cos(tt) 0 ];[0 0 1]];
            %             end
            %stickstick(1,:,i) = dpdp;
            askel = rotskel(prot.protoskel2+repmat([0 height/2 0],num_of_points_in_stick,1),0,PHI,pi/2-tt);
            for j = 1:num_of_points_in_stick
                %                 stickstick(j,:,i) = (ttmatz*PHIMAT*ttmatx*prot.protoskel2(j,:).').'/height*l+dpdp-l/2*cos(tt)*[cos(PHI) 0 sin(PHI)]+[0 height/2 0];
                stickstick(j,:,i) = askel(j,:)/height*l+dpdp-l/2*cos(tt)*[cos(PHI) 0 sin(PHI)];
                
            end
            %there is something wrong with my matrix multiplication I think,   but I have no time to be elegant about it
            %or probably means I am wrong about the kinect data's axis; in any case, this would only affect conformskel mirror functions,
            %I should plot database(posei), hold and plot
            %mirrordatabase(posei) to see if the skeleton is upsidedown...
            %2/3 chances it isnt...
            %quick and dirty
            %stickstick(:,1,i) = - stickstick(:,1,i);
            
        end
end
%%% the initial velocities are not zero, but I had to artificially change
%%% the x point because of limitations of the simulated stick. They are
%%% already zeroed, so I just need to start from the second point

%%% for the next ones I will calculate the points
for i = 2:simdim
    stickvel(:,:,i-1) = stickstick(:,:,i)-stickstick(:,:,i-1);
end

%stickstick; % ok, I forgot that the reshape happens latter %reshape(stickstick,[],simdim);


end
function [extinput_clipped, extinput, inputends,y, removeremove, indexes, awko] = setinput(arq_connect, savestruc,data_size, svst_t_v) %needs to receive the correct data size so that generateidx may work well
%%%%%% this is the place to get long inputs actually.
%arqconnect has only the current layer, so it is flat
%inputends need to be the same for everything to work out fine
%theoretically it makes sense that they are not the same size and then the
%smallest should be used and the end bits of each action set, discarded and
%then rematched to fit the real correspondent. I don't really know how to
%do that, maybe I need to match each action with some extra indexing, or
%make a clever indexing function that will discard the right amount of end
%bits at the right part
% Or I perhaps should carry each action separatelly, because it would make
% things easier, but this would require a major rewrite of everything I did
% so far. So in short: same "ends" for every component.
extinput = [];
midremove = [];
awko = [];
inputinput = cell(length(arq_connect.sourcelayer),1);
removeremove = struct([]);
awk = inputinput; %it is also the same size...
%if inputends dont coincide this function will give a strange error
inputends = [];
[posidx, velidx] = generateidx(data_size, arq_connect.params.skelldef);
for j = 1:length(arq_connect.sourcelayer)
    foundmysource = false;
    for i = 1:length(savestruc.gas)
        if strcmp(arq_connect.sourcelayer{j}, savestruc.gas(i).name)
            if isempty( svst_t_v.gas(i).bestmatchbyindex)
                error('wrong computation order. bestmatch field not yet defined.')
            end
            oldinputends = inputends;
            [inputinput{j},inputends,y, indexes] = longinput( savestruc.gas(i).nodes(:,svst_t_v.gas(i).bestmatchbyindex), arq_connect.q, svst_t_v.gas(i).inputs.input_ends, svst_t_v.gas(i).y,svst_t_v.gas(i).inputs.index);
            
            %%%check for misalignments of inputends
            if ~isempty(oldinputends)
                if ~all(oldinputends==inputends)
                    error('Misaligned layers! Alignment not yet implemented.')
                end
            end
            %%% old  longinput call. I will no longer create .bestmatch, so
            %%% I need to create it on the fly from gasnodes
            %            [inputinput{j},inputends,y] = longinput( svst_t_v.gas(i).bestmatch, arq_connect.q, svst_t_v.gas(i).inputs.input_ends, svst_t_v.gas(i).y);
            
            %inputinput{j} = longinput(savestruc.gas(i).bestmatch; %
            removeremove = structcat(svst_t_v.gas(i).whotokill, removeremove);
            %%% this part will construct my newly created awk vector out of
            %%% initial awk vectors
            awk{j} = makeawk(arq_connect.q, svst_t_v.gas(i).inputs.awk);
            foundmysource = true;
        end
    end
    if ~foundmysource
        if strcmp(arq_connect.layertype, 'pos')
            [inputinput{j},inputends,y, indexes] = longinput(svst_t_v.data(posidx,:), arq_connect.q, svst_t_v.ends, svst_t_v.y, (1:size(svst_t_v.data,2)));
            %inputinput{j} = svst_t_v.data(posidx,:); %
            %ends is savestructure.train.ends
            awk{j} = makeawk(arq_connect.q, arq_connect.params.skelldef.awk.pos);
        elseif strcmp(arq_connect.layertype, 'vel')
            [inputinput{j},inputends,y, indexes] = longinput(svst_t_v.data(velidx,:), arq_connect.q, svst_t_v.ends, svst_t_v.y, (1:size(svst_t_v.data,2)));
            %inputinput{j} = svst_t_v.data(velidx,:); %
            %ends is savestructure.train.ends
            awk{j} = makeawk(arq_connect.q, arq_connect.params.skelldef.awk.vel);
        elseif strcmp(arq_connect.layertype, 'all')
            [inputinput{j},inputends,y, indexes] = longinput(svst_t_v.data, arq_connect.q, svst_t_v.ends, svst_t_v.y, (1:size(svst_t_v.data,2)));
            %inputinput{j} = svst_t_v.data; %
            %ends is savestructure.train.ends
            awk{j} = makeawk(arq_connect.q, [arq_connect.params.skelldef.awk.pos;  arq_connect.params.skelldef.awk.vel] );
        end
    end
    if isempty(inputinput)
        error(strcat('Unknown layer type:', arq_connect.layertype,'or sourcelayer:',arq_connect.sourcelayer))
    end
end
if length(inputinput)>1
    for i = 1:length(inputinput)
        extinput = cat(1,extinput,inputinput{i}); % this part should check for the right ends, ends should also be a cell array, and they should be concatenated properly
        %%% dealing with possible empty sets::
        if ~isempty(removeremove)
            midremove = structcat(midremove,removeremove); %{i}
            %midremove = cat(1,midremove,removeremove{i}); %{i}
        end
        awko = cat(1,awko,awk{i});
    end
else
    extinput = inputinput{:};
    midremove = removeremove; %no turtles!
    awko = awk{:};
    %oh, it may be wrong,,, have
    %to check wrappung and unwrapping %%it was wrong, I will check
    %unwrapping inside removebaddata
    %[extinput_clipped, inputends_clipped, y_clipped]= removebaddata(extinput, inputends, y, removeremove); % this wrong, since I will only avoid putting bad sets into the gas. so it is fortunately simpler than I thought!
    
end
extinput_clipped= removebaddata(extinput, indexes, midremove, arq_connect.q);
end
function awk = makeawk(q,inawk)
awk = repmat(inawk,q(1),1);
end
function [linput,newends, newy, indexes] = longinput(shortinput, qp, ends, y, iindex)
% this function was getting messy, so I decided to recreate the structure
% that generated her, so to make easier debugging
% It is very disellegant of me. I apologise.
q = qp(1);
switch length(qp)
    case 1
        p = 0;
        r = 1;
    case 2
        p = qp(2);
        r = 1;
    case 3
        p = qp(2);
        r = qp(3);
end

realends = cumsum(ends,2);
actionstructure = struct;
actionstructure(1:size(ends,2)) = struct();
actionstructure(1).pose = shortinput(:,1:realends(1));
actionstructure(1).end = ends(1);
actionstructure(1).y = y(:,realends(1));
actionstructure(1).index = iindex(1:ends(1));

for i = 2:size(ends,2)
    actionstructure(i).pose = shortinput(:,realends(i-1)+1:realends(i));
    actionstructure(i).end = ends(i);
    actionstructure(i).y = y(:,realends(i));
    actionstructure(i).index = iindex(realends(i-1):realends(i));
end
shortdim = size(shortinput,1);
for i = 1:length(actionstructure)
    m = 1;
    for j = 1:1+p:actionstructure(i).end
        a = zeros(shortdim*q,1);
        indexx = zeros(1,q);
        if j+q*r-1>actionstructure(i).end
            %cant complete the whole vector!
            break
        else
            k = 1;
            for lop = 1:q
                a(1+(k-1)*shortdim:k*shortdim) = actionstructure(i).pose(:,j+lop*r-1);
                indexx(lop) = actionstructure(i).index(j+lop*r-1);
                k = k+1;
            end
        end
        %have to save a somewhere
        actionstructure(i).long(m).vec = a;
        actionstructure(i).long(m).index = indexx;
        m = m+1;
    end
    %should concatenate long now
    actionstructure(i).newend = length(actionstructure(i).long);
    actionstructure(i).longinput = zeros(q*shortdim,actionstructure(i).newend);
    actionstructure(i).longy = repmat(actionstructure(i).y,1,actionstructure(i).newend);
    actionstructure(i).longindex = zeros(q,size(actionstructure(i).longy,2));
    for j = 1:actionstructure(i).newend
        actionstructure(i).longinput(:,j) = actionstructure(i).long(j).vec;
        actionstructure(i).longindex(:,j) = actionstructure(i).long(j).index;
    end
end
linput = actionstructure(1).longinput;
newy = actionstructure(1).longy;
newends = zeros(1,length(actionstructure));
newends(1) = actionstructure(1).newend;
indexes = actionstructure(1).longindex;
for i = 2:length(actionstructure)
    linput = cat(2,linput,actionstructure(i).longinput);
    newy = cat(2,newy, actionstructure(i).longy);
    newends(i) = actionstructure(i).newend;
    indexes = cat(2,indexes, actionstructure(i).longindex);
end
end
function stringmatrix = writedownmatrix(matrix)
stringmatrix = '';
for i =1:size(matrix,1)
    for j = 1:size(matrix,2)
        stringmatrix = strcat(stringmatrix,'(', num2str(i),',',num2str(j),'):', num2str(matrix(i,j)),'\t');
    end
end
end
function [ matmat, matmat_byindex] = genbestmmatrix(nodes, data, ~,~)
%matmat = zeros(size(nodes,1),size(data,2));
%matmat_byindex = zeros(1,size(data,2));
[~,matmat_byindex] = pdist2(nodes',data','euclidean','Smallest',1);
matmat = data(matmat_byindex);
%
% for i = 1:size(data,2)
%        [ matmat(:,i), matmat_byindex(i)] = bestmatchingunit(data(:,i),gwr_nodes,whichisit,q);
% end

% % old genbestmatch. I figured out it is the other way around, which makes
% more sense, so I should just filter spatially my data, so the
% bestmatching data should have the same dimension as the initial dataset,
% duh...
% matmat = zeros(size(data,1),size(gwr_nodes,2));
% for i = 1:size(gwr_nodes,2) %%%%%%%%%% it is actually the other way around!!!!!
%         matmat(:,i) = bestmatchingunit(gwr_nodes(:,i),data,whichisit);
% end
% end
end
function labels = labeling(nodes, data, y)
% the labeling function for the GWR and GNG
% cf parisi, adopt the label of the nearest node

%so first we need to know the label of each node
% we do exactly as parisi, with the labeling after the learning phase
% this he calls the training phase (but everything is the training phase)
% go through the nodeset and see in the data_set what is more similar
%%%%%MESSAGES
dbgmsg('Applying labels to the prototypical nodes.',1)
%%%%%
try
    [~,ni] = pdist2(data',nodes', 'euclidean', 'Smallest',1);
    labels = y(:,ni);
catch
    [labels, ~ ]= labelling(nodes, data, y);
end


end
function [labels, ni1 ]= labelling(nodes, data, y)
maxmax = size(nodes,2);
labels = zeros(1,maxmax);

for i = 1:maxmax
    [~, ~, ni1 , ~ , ~] = findnearest(nodes(:,i), data); % s1 is the index of the nearest point in data
    labels(i) = y(ni1);
end
end
function [train_class, val_class, nodesl] = labeller(nodes, train_bestmatchbyindex, val_bestmatchbyindex, train_input, y_train)

nodesl = labeling(nodes,train_input,y_train);

tcsize = size(train_bestmatchbyindex,2);
vcsize = size(val_bestmatchbyindex,2);
ycsize = size(y_train,1);

train_class = zeros(ycsize,tcsize);
val_class = zeros(ycsize,vcsize);

for i =1:tcsize
    train_class(:,i) = nodesl(:,train_bestmatchbyindex(i));
end
for i =1:vcsize
    val_class(:,i) = nodesl(:,val_bestmatchbyindex(i));
end
end
